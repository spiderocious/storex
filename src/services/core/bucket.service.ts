import {
  BucketServiceImpl,
  CreateBucketRequest,
  UpdateBucketRequest,
  BucketStatsResponse,
} from '../impl/bucket.service.impl';
import { bucketRepository } from '@/repositories/core/bucket.repository';
import { fileRepository } from '@/repositories/core/file.repository';
import { userRepository } from '@/repositories/core/user.repository';
import { IBucket } from '@/models';
import { generateAppID } from '@/utils/id';

class BucketService implements BucketServiceImpl {
  async createBucket(bucketData: CreateBucketRequest): Promise<IBucket> {
    const { name, ownerId } = bucketData;

    // Validate required fields
    if (!name || name.trim() === '') {
      throw new Error('Bucket name is required');
    }

    if (!ownerId || ownerId.trim() === '') {
      throw new Error('Owner ID is required');
    }

    // Check if owner exists
    const owner = await userRepository.getUserByID(ownerId);
    if (!owner) {
      throw new Error('Owner not found');
    }

    // Check if bucket with same name already exists for this owner
    const ownerBuckets = await bucketRepository.getBucketsByOwnerID(ownerId);
    const existingBucket = ownerBuckets.find(
      bucket => bucket.name.toLowerCase() === name.toLowerCase()
    );

    if (existingBucket) {
      throw new Error('Bucket with this name already exists for this owner');
    }

    // Create bucket (keys will be auto-generated by the model)
    const newBucket = await bucketRepository.createBucket({
      id: generateAppID('BUCKET'),
      name: name.trim(),
      ownerId,
      downloadCount: 0,
      uploadCount: 0,
      totalSize: 0,
      fileCount: 0,
    } as IBucket);

    return newBucket;
  }

  async getBucketById(bucketId: string): Promise<IBucket | null> {
    if (!bucketId || bucketId.trim() === '') {
      throw new Error('Bucket ID is required');
    }

    return await bucketRepository.getBucketByID(bucketId);
  }

  async getBucketsByOwnerId(ownerId: string): Promise<IBucket[]> {
    if (!ownerId || ownerId.trim() === '') {
      throw new Error('Owner ID is required');
    }

    // Verify owner exists
    const owner = await userRepository.getUserByID(ownerId);
    if (!owner) {
      throw new Error('Owner not found');
    }

    return await bucketRepository.getBucketsByOwnerID(ownerId);
  }

  async getBucketByPublicKey(publicKey: string): Promise<IBucket | null> {
    if (!publicKey || publicKey.trim() === '') {
      throw new Error('Public key is required');
    }

    return await bucketRepository.getBucketByPublicKey(publicKey);
  }

  async getBucketByPrivateKey(privateKey: string): Promise<IBucket | null> {
    if (!privateKey || privateKey.trim() === '') {
      throw new Error('Private key is required');
    }

    return await bucketRepository.getBucketByPrivateKey(privateKey);
  }

  async updateBucket(bucketId: string, updateData: UpdateBucketRequest): Promise<IBucket | null> {
    if (!bucketId || bucketId.trim() === '') {
      throw new Error('Bucket ID is required');
    }

    // Check if bucket exists
    const existingBucket = await bucketRepository.getBucketByID(bucketId);
    if (!existingBucket) {
      throw new Error('Bucket not found');
    }

    // If name is being updated, check if new name already exists for the owner
    if (updateData.name && updateData.name.trim() !== existingBucket.name) {
      const ownerBuckets = await bucketRepository.getBucketsByOwnerID(existingBucket.ownerId);
      const bucketWithNewName = ownerBuckets.find(
        bucket =>
          bucket.name.toLowerCase() === updateData.name!.toLowerCase() && bucket._id !== bucketId
      );

      if (bucketWithNewName) {
        throw new Error('Bucket with this name already exists for this owner');
      }

      // Trim the name
      updateData.name = updateData.name.trim();
    }

    return await bucketRepository.updateBucket(bucketId, updateData);
  }

  async deleteBucket(bucketId: string): Promise<boolean> {
    if (!bucketId || bucketId.trim() === '') {
      throw new Error('Bucket ID is required');
    }

    // Check if bucket exists
    const existingBucket = await bucketRepository.getBucketByID(bucketId);
    if (!existingBucket) {
      throw new Error('Bucket not found');
    }

    // Check if bucket has files
    const files = await fileRepository.getFilesByBucketID(bucketId);
    if (files.length > 0) {
      throw new Error('Cannot delete bucket that contains files. Delete all files first.');
    }

    // Delete bucket
    return await bucketRepository.deleteBucket(bucketId);
  }

  async getBucketStats(bucketId: string): Promise<BucketStatsResponse | null> {
    if (!bucketId || bucketId.trim() === '') {
      throw new Error('Bucket ID is required');
    }

    const bucket = await bucketRepository.getBucketByID(bucketId);
    if (!bucket) {
      return null;
    }

    return {
      bucketId: bucket._id,
      name: bucket.name,
      fileCount: bucket.fileCount,
      totalSize: bucket.totalSize,
      downloadCount: bucket.downloadCount,
      uploadCount: bucket.uploadCount,
    };
  }
}

export const bucketService = new BucketService();
